

--  some code here is modified from filtered complex code



FilteredVectorSpace = new Type of HashTable

filteredVectorSpace = method()

filteredVectorSpace(List) := HashTable => (L) -> (
    maps = L;
       V = target maps#0;-- By default the ambient vspace is target of first map.           
 P := {0 => V} | apply (#maps,  p -> p+1 => image maps#p);
  new FilteredVectorSpace from reverse(P)
   )



FilteredVectorSpace^ ZZ := Module => (V,j) -> (
    Keys := keys V;
   Max := max Keys;
   Min := min Keys;
   if j >= Min and j <= Max  then return V#j else (
       if j < Min then (return V#Min) else( return image(0*id_(V#Min)))
       );
    )


gr = method()
gr(FilteredVectorSpace,ZZ) := (V,n) -> (
    return V^n/V^(n+1)
    )
 

--AssociatedGradedObject = new Type of HashTable

--associatedGradedObject = method()

--associatedGradedObject(FilteredVectorSpace) := HashTable =>(V) -> (
V--spots = keys V;
--gr := new HashTable from apply(spots, i-> i=> V^(i)/V^(i+1));
--return gr
--    )


--AssociatedGradedObject^ ZZ := Module =>(Gr, j) -> (
--    spots = keys Gr;
--    if spots#?j then return Gr#j else return $V
--    )

--
--
-- scratch test

keys V

k=QQ
V=k^4
f0=id_V
V0=image f0
f1=map(V,V,matrix(k,{{0,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,0}}))
V1=image f1

L={f0,f1}


apply(#L,i->i)

V = filteredVectorSpace({f0,f1})
l = keys V

V^2

V^3

V^4

V^1

V^(-1)

V^(-2)

V^0

gr = associatedGradedObject(V)

prune gr#1

prune gr#2

prune gr#0


keys V
